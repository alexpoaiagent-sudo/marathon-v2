name: Daily Health Check + Summary

on:
  schedule:
    # 09:00 Helsinki –∑–∏–º–æ–π ‚âà 07:00 UTC
    - cron: '0 7 * * *'
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  contents: read
  issues: write

jobs:
  health-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run health check
        id: hc
        shell: bash
        run: |
          set +e
          mkdir -p .tmp
          chmod +x scripts/check-integrity.sh
          bash scripts/check-integrity.sh |& tee .tmp/health.log
          exit_code=${PIPESTATUS[0]}
          echo "exit_code=$exit_code" >> "$GITHUB_OUTPUT"
          exit 0

      - name: Ensure report exists
        if: always()
        shell: bash
        run: |
          mkdir -p reports
          today="$(date -u +%F)"
          exit_code="${{ steps.hc.outputs.exit_code }}"
          shopt -s nullglob
          reports=(reports/health-check-*.md)
          shopt -u nullglob
          if [ ${#reports[@]} -eq 0 ]; then
            log_tail="(log not found)"
            if [ -f .tmp/health.log ]; then
              log_tail=$(tail -n 20 .tmp/health.log)
            fi
            {
              echo "# Health Check Report (${today})"
              echo
              echo "- Status: ${exit_code:-unknown}"
              echo "- Generated: $today (fallback)"
              echo
              echo "## Last 20 lines of log"
              echo '```'
              echo "${log_tail}"
              echo '```'
              echo
              echo "> –û—Ç—á—ë—Ç –Ω–µ –±—ã–ª —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —Å–∫—Ä–∏–ø—Ç–æ–º, —Å–æ–∑–¥–∞–Ω fallback"
            } > "reports/health-check-${today}.md"
          fi

      - name: Upload report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-report-${{ github.run_number }}
          path: reports/health-check-*.md
          retention-days: 30
          if-no-files-found: warn

      - name: Create Issue if problems found
        if: ${{ steps.hc.outputs.exit_code && steps.hc.outputs.exit_code != '0' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const dir = 'reports';
            const files = fs.existsSync(dir) ? fs.readdirSync(dir).filter(f => f.startsWith('health-check-')) : [];
            const latest = files.sort().reverse()[0];
            const body = latest ? fs.readFileSync(`${dir}/${latest}`, 'utf8') : 'Health-check –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π, –Ω–æ –æ—Ç—á—ë—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.';
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º—ã (health-check) ‚Äî ${new Date().toISOString().split('T')[0]}`,
              body,
              labels: ['health-check', '–∞–≤—Ç–æ–º–∞—Ç–∏–∫–∞']
            });

  daily-summary:
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Collect last 24h changes
        shell: bash
        run: |
          mkdir -p .tmp
          git log --since="24 hours ago" --pretty=format:"- %h %ad %an %s" --date=short > .tmp/commits.txt || true
          git diff --since="24 hours ago" > .tmp/diff.patch || true
          echo "DIFF_BYTES=$(wc -c < .tmp/diff.patch | tr -d ' ')" >> $GITHUB_ENV

      - name: Collect trafficlight stats
        shell: bash
        run: |
          mkdir -p .tmp
          python3 - << 'PY'
          import datetime
          import os
          import pathlib
          import re

          base = pathlib.Path('.')
          exclude = {'.git', '.github', 'node_modules', 'vendor', '.tmp'}

          counts = {'green': 0, 'yellow': 0, 'red': 0}
          red_files = []
          next_review_items = []

          today = datetime.date.today()
          soon_threshold = today + datetime.timedelta(days=14)

          for root, dirs, files in os.walk(base):
            # prune excluded directories
            dirs[:] = [d for d in dirs if d not in exclude and not d.startswith('.git')]
            path_root = pathlib.Path(root)
            if any(part in exclude for part in path_root.parts):
              continue
            for name in files:
              if not name.lower().endswith('.md'):
                continue
              path = path_root / name
              rel_path = path.relative_to(base)
              try:
                content = path.read_text(encoding='utf-8')
              except Exception:
                continue

              lines = content.splitlines()
              if not lines or lines[0].strip() != '---':
                continue
              frontmatter_end = None
              for idx in range(1, len(lines)):
                if lines[idx].strip() == '---':
                  frontmatter_end = idx
                  break
              if frontmatter_end is None:
                continue

              frontmatter = '\n'.join(lines[1:frontmatter_end])
              status_match = re.search(r'^status:\s*(\w+)', frontmatter, re.IGNORECASE | re.MULTILINE)
              if not status_match:
                continue

              status = status_match.group(1).lower()
              if status in counts:
                counts[status] += 1
              else:
                continue

              if status == 'red':
                red_files.append(str(rel_path))

              date_match = re.search(r'^next_review:\s*([0-9]{4}-[0-9]{2}-[0-9]{2})', frontmatter, re.IGNORECASE | re.MULTILINE)
              if date_match:
                try:
                  date_value = datetime.date.fromisoformat(date_match.group(1))
                except ValueError:
                  date_value = None
                if date_value and date_value <= soon_threshold:
                  next_review_items.append((date_value, str(rel_path)))

          red_files = red_files[:10]
          next_review_items.sort(key=lambda x: x[0])
          next_review_items = next_review_items[:10]

          lines_out = ["## –°–≤–µ—Ç–æ—Ñ–æ—Ä –∫–∞—á–µ—Å—Ç–≤–∞ (YAML frontmatter)", ""]
          total_marked = sum(counts.values())
          if total_marked == 0:
            lines_out.append("–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö")
          else:
            lines_out.append(f"üü¢ / üü° / üî¥: {counts['green']} / {counts['yellow']} / {counts['red']}")
            lines_out.append("")
            lines_out.append("### üî¥ –ù–∞ –¥–æ—Ä–∞–±–æ—Ç–∫—É")
            if red_files:
              lines_out.extend(f"- {path}" for path in red_files)
            else:
              lines_out.append("- –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö")
            lines_out.append("")
            lines_out.append("### üìÖ –†–µ–≤–∏–∑–∏—è —Å–∫–æ—Ä–æ")
            if next_review_items:
              for date_value, path in next_review_items:
                lines_out.append(f"- {date_value.isoformat()} ‚Äî {path}")
            else:
              lines_out.append("- –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö")

          pathlib.Path('.tmp/trafficlight.md').write_text('\n'.join(lines_out) + '\n', encoding='utf-8')
          PY

      - name: Generate summary via LLM
        id: llm
        continue-on-error: true
        env:
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
        shell: bash
        run: |
          set +e
          mkdir -p .tmp
          log_file=".tmp/llm.log"
          python3 - << 'PY'
          import os, json, pathlib, textwrap, datetime, urllib.request

          # --- –ù–ê–°–¢–†–û–ô–ö–ê –ü–†–û–í–ê–ô–î–ï–†–ê ---
          # –ó–¥–µ—Å—å –ø—Ä–∏–º–µ—Ä –ø–æ–¥ OpenAI Responses API.
          # –ï—Å–ª–∏ —É —Ç–µ–±—è Claude ‚Äî —Å–∫–∞–∂–∏, –∏ —è –¥–∞–º –≥–æ—Ç–æ–≤—ã–π –±–ª–æ–∫ –ø–æ–¥ Anthropic.
          api_key = os.environ["LLM_API_KEY"]

          commits = pathlib.Path(".tmp/commits.txt").read_text(encoding="utf-8", errors="ignore")
          diff = pathlib.Path(".tmp/diff.patch").read_text(encoding="utf-8", errors="ignore")
          trafficlight = pathlib.Path(".tmp/trafficlight.md").read_text(encoding="utf-8", errors="ignore") if pathlib.Path(".tmp/trafficlight.md").exists() else "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"

          # –û–≥—Ä–∞–Ω–∏—á–∏–º diff, —á—Ç–æ–±—ã –Ω–µ —É–ª–µ—Ç–µ—Ç—å –≤ –ª–∏–º–∏—Ç—ã
          max_chars = 120_000
          if len(diff) > max_chars:
            diff = diff[:max_chars] + "\n\n[diff truncated]\n"

          today = datetime.date.today().isoformat()

          prompt = f"""
          –¢—ã ‚Äî –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –ø—Ä–æ–µ–∫—Ç–∞ marathon-v2. –°—Ñ–æ—Ä–º–∏—Ä—É–π –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é —Å–≤–æ–¥–∫—É –ø–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞.

          –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ —Å–≤–æ–¥–∫–µ:
          1) –ö–æ—Ä–æ—Ç–∫–∏–π –∏—Ç–æ–≥ (3‚Äì6 –ø—É–Ω–∫—Ç–æ–≤)
          2) –ß—Ç–æ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å (–ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞–º/–ø–∞–ø–∫–∞–º)
          3) –†–∏—Å–∫–∏/–ø–æ–ª–æ–º–∫–∏ (–µ—Å–ª–∏ –≤–∏–¥–Ω–æ –ø–æ diff)
          4) To-do –Ω–∞ –∑–∞–≤—Ç—Ä–∞ (3‚Äì7 –ø—É–Ω–∫—Ç–æ–≤)
          5) –ï—Å–ª–∏ –∫–æ–º–º–∏—Ç–æ–≤ –Ω–µ—Ç ‚Äî —Å–∫–∞–∂–∏, —á—Ç–æ –∏–∑–º–µ–Ω–µ–Ω–∏–π –Ω–µ –±—ã–ª–æ.

          –°–≤–µ—Ç–æ—Ñ–æ—Ä –∫–∞—á–µ—Å—Ç–≤–∞ (–¥–∞–Ω–Ω—ã–µ –Ω–∏–∂–µ):
          {trafficlight or "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"}

          –ö–æ–º–º–∏—Ç—ã:
          {commits or "–Ω–µ—Ç"}

          Diff:
          {diff or "–Ω–µ—Ç"}

          –§–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ä–∞–∑–¥–µ–ª:
          ## –°–≤–µ—Ç–æ—Ñ–æ—Ä –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π
          - —Å—Ç—Ä–æ–∫—É —Å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º "üü¢ / üü° / üî¥: X / Y / Z"
          - –±–ª–æ–∫ "üî¥ –ù–∞ –¥–æ—Ä–∞–±–æ—Ç–∫—É (—Ç–æ–ø-5)" —Å–æ —Å—Å—ã–ª–∫–∞–º–∏/–ø—É—Ç—è–º–∏ (–µ—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç, –Ω–∞–ø–∏—à–∏ "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö")
          - –±–ª–æ–∫ "üìÖ –†–µ–≤–∏–∑–∏—è —Å–∫–æ—Ä–æ (—Ç–æ–ø-5)" (–µ—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç, –Ω–∞–ø–∏—à–∏ "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö")
          """

          # OpenAI Responses API (–ø—Ä–∏–º–µ—Ä)
          url = "https://api.openai.com/v1/responses"
          headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json",
          }
          payload = {
            "model": "gpt-4.1-mini",
            "input": prompt,
          }

          req = urllib.request.Request(url, data=json.dumps(payload).encode("utf-8"), headers=headers, method="POST")
          with urllib.request.urlopen(req, timeout=60) as resp:
            data = json.loads(resp.read().decode("utf-8"))

          # –î–æ—Å—Ç–∞—ë–º —Ç–µ–∫—Å—Ç (—É–ø—Ä–æ—â—ë–Ω–Ω–æ)
          text = ""
          for item in data.get("output", []):
            for c in item.get("content", []):
              if c.get("type") == "output_text":
                text += c.get("text", "")
          text = text.strip() or "(LLM –≤–µ—Ä–Ω—É–ª –ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç)"

          out = f"# –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Å–≤–æ–¥–∫–∞ ‚Äî {today}\n\n{text}\n\n---\n\n{trafficlight}\n"
          pathlib.Path(".tmp/summary.md").write_text(out, encoding="utf-8")
          print("Wrote .tmp/summary.md")
          PY

          status=$?
          echo "llm_status=$status" >> "$GITHUB_OUTPUT"
          echo "LLM step finished with status $status" >> "$log_file"
          if [ $status -ne 0 ]; then
            echo "LLM —à–∞–≥ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π, —Å–º. –ª–æ–≥." >> "$log_file"
          fi
      - name: Build fallback summary
        if: always()
        env:
          LLM_STATUS: ${{ steps.llm.outputs.llm_status || '1' }}
        shell: bash
        run: |
          mkdir -p .tmp
          summary_exists=0
          if [ -s .tmp/summary.md ] && [ "${LLM_STATUS}" = "0" ]; then
            summary_exists=1
          fi

          if [ $summary_exists -eq 0 ]; then
            log="$(cat .tmp/llm.log 2>/dev/null || echo "–õ–æ–≥ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.")"
            commits="$(cat .tmp/commits.txt 2>/dev/null || echo "–Ω–µ—Ç")"
            diff_size="$(wc -c < .tmp/diff.patch 2>/dev/null || echo "0")"

            {
              echo "# –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Å–≤–æ–¥–∫–∞ ‚Äî $(date -I)"
              echo
              echo "‚ö†Ô∏è LLM —à–∞–≥ –Ω–µ –ø—Ä–æ—à—ë–ª (–∫–æ–¥ ${LLM_STATUS:-–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ})."
              echo
              echo "–õ–æ–≥ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 200 —Å—Ç—Ä–æ–∫):"
              echo '```'
              printf '%s\n' "$log" | tail -n 200
              echo '```'
              echo
              echo "–ö–æ–º–º–∏—Ç—ã –∑–∞ 24 —á–∞—Å–∞:"
              echo '```'
              printf '%s\n' "$commits"
              echo '```'
              echo
              echo "–†–∞–∑–º–µ—Ä diff (–±–∞–π—Ç): ${diff_size}"
              echo
              echo "---"
              echo
              cat .tmp/trafficlight.md 2>/dev/null || echo "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
            } > .tmp/summary.md
          fi

          if [ -s .tmp/trafficlight.md ] && ! grep -q "–°–≤–µ—Ç–æ—Ñ–æ—Ä –∫–∞—á–µ—Å—Ç–≤–∞ (YAML frontmatter)" .tmp/summary.md; then
            printf "\n\n---\n\n%s\n" "$(cat .tmp/trafficlight.md)" >> .tmp/summary.md
          fi

      - name: Create Issue (daily summary)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('.tmp/summary.md', 'utf8');
            const today = new Date().toISOString().split('T')[0];

            // –ß—Ç–æ–±—ã –Ω–µ —Å–ø–∞–º–∏—Ç—å, –º–æ–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å, –Ω–µ —Å–æ–∑–¥–∞–Ω–∞ –ª–∏ —É–∂–µ —Å–≤–æ–¥–∫–∞ –∑–∞ —Å–µ–≥–æ–¥–Ω—è:
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'daily-summary',
              per_page: 50
            });
            const existing = issues.find(i => i.title.includes(today));
            if (!existing) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üóìÔ∏è –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Å–≤–æ–¥–∫–∞ ‚Äî ${today}`,
                body,
                labels: ['daily-summary', '–∞–≤—Ç–æ–º–∞—Ç–∏–∫–∞']
              });
            } else {
              core.info(`Issue for ${today} already exists (##${existing.number}), adding comment.`);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: body
              });
            }
